
# ////

# پس سینتکس تاپل اینه
t=(1,2,3)
print(type(t))
# <class 'tuple'>
# ///////


# تاپل ها تغیر ناپذیر هستند
print(t(0)=4)
# TypeError: 'tuple' object is not callable

# تاپل ها تغیر ناپذیر هستند
print(t[0]=4)
# TypeError: 'tuple' object is not callable


# ////////

# این تاپله
t=(4,) 
# اما این یه عدده خالیه
t=(4,) 

# ////////
# برش زدن تاپل ها Eه
t=(1,'no',3,'hello',5,6,7)

print(t[2:6])
# (3, 'hello', 5, 6)


# ////////



# ////////////////
# تبدیل تاپل به استرینگ
# John#Peter#Vicky
myTuple = ("John", "Peter", "Vicky")
x = "#".join(myTuple)
print(x)

# 
# تاپل ها غیر قابل تغیر هستند

# /////////
# تبدیل تاپل به لیست

# //////////

# مکانیسم تغیر کردن .جابجا کردن
# اول اسپلیت می کنیم . سپس 

# ///////////////

# کار تبدیل دیکشنری به تاپل
ab={'bf': 4, 'cd':5 , 'fg':6 }
print(ab.items())
# dict_items([('bf', 4), ('cd', 5), ('fg', 6)])


# تبدیل اون دیکشنری به لیستی از تاپل های جفت
print(list(ab.items()))
# [('bf', 4), ('cd', 5), ('fg', 6)]
# ///////////

# آوردن تاپل در یک حلقه 
for kel , arz in list(ab.items()):
    print(kel)
# bf
# cd
# fg
for kel , arz in list(ab.items()):
    print(arz)
# 4
# 5
# 6
# //////////////
# کاربرد تابع و تاپل . تاپل در تابع

def counterer(first):
    big_count=0
    small_count=0
    for character in first:
        if character ==character.upper():
            big_count+=1
        else:
            small_count+=1
    return big_count , small_count
# این دو تا تاپل هستند
# برای اشاره بهشنون باید اون تابع را فراخوانی کرد
def big_smaler(sec):
    # اشاره به تاپل در یک  تابع دیگر . یعنی خروجی تابع که تاپل هستش را میدیدم در تابع دیگر
    if counterer(sec)[0] >counterer(sec)[1]:
        sec = sec.upper()
    else:
        sec = sec.lower()
    
    return sec

a='HasTam'

print(big_smaler(a))       
# ///////////////
# اگر دو تا ورودی هم بدیم مثل دو تا خروجی تاپل میده
vorodi='madam', 'maddam'
vorodi_not='tehran'

print(vorodi)
# ('madam', 'maddam')
print(vorodi_not)
# tehran
# ////////
# یک تاپل که باشه باز میکنه عناصر را و میشه اسم متغیر گذاشت روی هر عنصر مجزا تاپل
first=('ali',[1,2,4,8])
# first= name , grade    این سینتکس را خطا میده
name , grades =  first
print(name)
# ali
print(grades)
# [1, 2, 4, 8]


# ////
# اگر اولی لیست هم باشه میشه به تاپل برگردوند

first=['ali',[1,2,4,8]]
# first= name , grade    این سینتکس را خطا میده
name , grades =  first

print(name)
# ali

print(grades)
# [1, 2, 4, 8]



# ////////////
# دسته بندی لیستی از تاپل ها 
# بر اساس عنصر اول تاپل ها دسته بندی میکنه
A= [(11,4),(1,8),(54,43),(56,3),(1,4),(5,5)]
A.sort()
print(A)
# [(1, 4), (1, 8), (5, 5), (11, 4), (54, 43), (56, 3)]

# ///////
# دسته بندی لیستی از تاپل ها 
# بر اساس عنصر دوم 
# یا عنصر دلبخواه 
# به کمک لامبدا



# /////////////
# تاپلی از لیست ها را بداریم در حلقه اینجوری بهشون اشاره میکنیم
test_list = [(1, 'gfg'), (1, 'is'), (2, 'best'), (3, 'for'), (4, 'CS')]
for i, j in test_list:
    print(i , j)
# 1 gfg
# 1 is
# 2 best
# 3 for
# 4 CS

# ////////
# این میاد  هر تیکه را مساوی صفر قرار میده
count=sum=0
# که تازه اگر  سام را عوض کنیم کانت همون صفرش باقی میمونه

# //////////
# این یه تاپل میده
    for char in (my_members[5:]):
        dict[char[0]]= char[1] ,char[2]
# {'2022-01-16': ('9', '1')}
# ///////////

# تاپل تو در تو از یک لیست حلقه زدن
# حلقه زدن  در یک تاپل تودرتو

    my=[(('2022-01-16', 9), ('2022-01-16', 1)), (('2022-01-23', 14), ('2022-01-23', 1)), (('2022-01-30', 15), ('2022-01-30', 1)), (('2022-02-06', 13), ('2022-02-06', 1)), (('2022-02-13', 11), ('2022-02-13', 1)), (('2022-02-20', 10), ('2022-02-20', 1)), (('2022-02-27', 10), ('2022-02-27', 1)), (('2022-03-06', 9), ('2022-03-06', 1)), (('2022-03-13', 9), ('2022-03-13', 1)), (('2022-03-20', 15), ('2022-03-20', 2)), (('2022-03-27', 13), ('2022-03-27', 1)), (('2022-04-03', 14), ('2022-04-03', 1)), (('2022-04-10', 13), ('2022-04-10', 1)), (('2022-04-17', 18), ('2022-04-17', 1)), (('2022-04-24', 16), ('2022-04-24', 1)), (('2022-05-01', 18), ('2022-05-01', 1)), (('2022-05-08', 14), ('2022-05-08', 1)), (('2022-05-15', 13), ('2022-05-15', 1)), (('2022-05-22', 13), ('2022-05-22', 1)), (('2022-05-29', 18), ('2022-05-29', 6)), (('2022-06-05', 16), ('2022-06-05', 5)), (('2022-06-12', 10), ('2022-06-12', 2)), (('2022-06-19', 10), ('2022-06-19', 2)), (('2022-06-26', 10), ('2022-06-26', 1)), (('2022-07-03', 9), ('2022-07-03', 1)), (('2022-07-10', 11), ('2022-07-10', 1)), (('2022-07-17', 11), ('2022-07-17', 1)), (('2022-07-24', 10), ('2022-07-24',
1)), (('2022-07-31', 13), ('2022-07-31', 1)), (('2022-08-07', 14), ('2022-08-07', 1)), (('2022-08-14', 9), ('2022-08-14', 2)), (('2022-08-21', 11), ('2022-08-21', 1)), (('2022-08-28', 15), ('2022-08-28', 1)), (('2022-09-04', 18), ('2022-09-04', 1)), (('2022-09-11', 100), ('2022-09-11', 1)), (('2022-09-18', 93), ('2022-09-18', 4)), (('2022-09-25', 61), ('2022-09-25', 4)), (('2022-10-02', 85), ('2022-10-02', 4)), (('2022-10-09', 38), ('2022-10-09', 4)), (('2022-10-16', 33), ('2022-10-16', 6)), (('2022-10-23', 29), ('2022-10-23', 4)), (('2022-10-30', 27), ('2022-10-30', 3)), (('2022-11-06', 19), ('2022-11-06', 3)), (('2022-11-13', 25), ('2022-11-13', 3)), (('2022-11-20', 22), ('2022-11-20', 2)), (('2022-11-27', 19), ('2022-11-27', 2)), (('2022-12-04', 30), ('2022-12-04', 2)), (('2022-12-11', 19), ('2022-12-11', 2)), (('2022-12-18', 17), ('2022-12-18', 2)), (('2022-12-25', 17), ('2022-12-25', 2)), (('2023-01-01', 21), ('2023-01-01', 2)), (('2023-01-08', 21), ('2023-01-08', 2))]
    # dictio=collections.defaultdict(list)

# /////
# اگر یک کاراکتر بزنیم
    for (madarbozorg) in my:
        print(madarbozorg)

# (('2022-01-16', 9), ('2022-01-16', 1))
# (('2022-01-23', 14), ('2022-01-23', 1))
# (('2022-01-30', 15), ('2022-01-30', 1))

# /////////////////
# این کد  هر تاپل را باز میکنه 
# یعنی تاپل مادربزرگ را به مادرها تقسیم میکنه
    for (madar),(pedar) in my:
        print(madar)
        print(pedar )
# ('2022-01-16', 9)
# ('2022-01-16', 1)

# ('2022-01-23', 14)
# ('2022-01-23', 1)


# //////
# اینجا چون در لیست ما کاراکتراول تاپل ما یکی بوده که همون تاریخ است پس یکی میشه
    for (madar,dokhtar),(pedar,pesar) in my:
        print(madar,dokhtar)
        print(pedar,pesar)

# 2022-01-16 9
# 2022-01-16 1

# 2022-01-23 14
# 2022-01-23 1


# ///////////
    for (madar,dokhtar),(pedar) in my:
        print(madar)
        print(pedar)

# 2022-01-16
# ('2022-01-16', 1)
# 2022-01-23
# ('2022-01-23', 1)
# 2022-01-30
# ('2022-01-30', 1)


# /////////////
    for (madar,dokhtar),(pedar) in my:
        print(madar,dokhtar)
        print(pedar)

# 2022-01-16 9
# ('2022-01-16', 1)
# 2022-01-23 14
# ('2022-01-23', 1)
# 2022-01-30 15
# ('2022-01-30', 1)

# /////////////
# حفظ ترتیب در تاپل ها

# با استفاده از دیکشنری و انومریت
T=('A','B','C','D')
 
D = dict(enumerate(T))
print(D)
# {0: 'A', 1: 'B', 2: 'C', 3: 'D'}

# حالا میتونیم حلقه بزنیم و به ترتیب چاپ کنه
T=(272043.0, 144376.33333333334, 178369.66666666666)
D = dict(enumerate(T))
print(D)
for char in D:
    print(D[char])

# /////
# # تاپل ها قابل خواندن نیستند
coffees = [

('“Americano”', 72, 1.90),

('“Macchiato”', 93, 2.10)

('“Latte”', 127, 2.30)

]
print(coffees)
# TypeError: 'tuple' object is not callable

# راه حل=
# پس از هر تاپل یه کاما بزار
coffees = [

('“Americano”', 72, 1.90),

('“Macchiato”', 93, 2.10),

('“Latte”', 127, 2.30)

]
print(coffees)
# [('“Americano”', 72, 1.9), ('“Macchiato”', 93, 2.1), ('“Latte”', 127, 2.3)]


# //////////
# اگر متغیری دو تا عنصر بداره میتونیم اسم گزاریش کنیم بریزیم توی متغیر جدا
import  re
oil_price='the price of the each galon is 10$ for 3galon'
just_price=re.findall(r'the price of the each galon is (\d+)\$ for (\d+)galon',oil_price)
price , boshke =(just_price[0])
print(price)
# 10
print(boshke)
# 3

# /////
# بجای
for m_r_h, pr, ra_si_cam_bat in zip(model_ram_hard, price, whole_list):

    perfect_list.append((m_r_h.text, pr.text, ra_si_cam_bat[0], ra_si_cam_bat[1], ra_si_cam_bat[2]))

# که اینو
#     ('گوشی موبايل سامسونگ مدل Galaxy A33 5G ظرفیت 128 گیگابایت - رم 6 گیگابایت', '5,399,000تومان',
     # ['128', '6.4', '48', '5000']),
    # یعنی عنصر دومی لیست باشه

    # تبدیل میکنه به
    # ('گوشی موبایل شیائومی مدل Redmi A1 Plus ظرفیت 32 گیگابایت رم 2 گیگابایت'
    #  , '6,965,000تومان'
    #  , '32', '6.52', '8')]
# که همش پخش میشه

    # میتونیم

            for m_r_h, pr, ra_si_cam_bat in zip(model_ram_hard, price, whole_list):
                new_tuple = (m_r_h.text, pr.text, [])
                # اینجا یه لیست خالی تعریف کرد. پس میشه لیست خالی را هم درون تاپل تعریف کرد
                for i in ra_si_cam_bat:
                    new_tuple[2].append(i)
                perfect_list.append(new_tuple)


# یا حتی خلاصه تر
perfect_list = [(m_r_h.text, pr.text, ra_si_cam_bat[i]) for m_r_h, pr, ra_si_cam_bat in
                            zip(model_ram_hard, price, whole_list) for i in range(len(ra_si_cam_bat))]
# همونه

# یا میتونیم به تاپل تبدیل کنم
for m_r_h, pr, ra_si_cam_bat in zip(model_ram_hard, price, whole_list):
    temp_list = []
    for i in ra_si_cam_bat:
        temp_list.append(i)

    perfect_list.append((m_r_h.text, pr.text, tuple(temp_list)))
 # ) ظرفیت 32 گیگابایت رم 2 گیگابایت', '6,965,000تومان', ('32', '6.52', '8', '5000'))

# //////////
